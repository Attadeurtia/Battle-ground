/**
 * \file survivant.c
 * \brief Contient toutes les fonctions utiles au mode de jeu survivant de
 * battle ground (gestion de l'évolution de la partie, implémentation des
 * structures de jeu, etc..) \author Lazare Maclouf \version 1 \date 25/02/2022
 */

#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../include/animations.h"
#include "../include/interactions.h"
#include "../include/interface.h"
#include "../include/structures.h"
#include "../include/vagues.h"
#include "../include/survivant.h"
#define V 5
#define y_entity 470
#define x_def 100
#define y_def 470
#define pv_joueur 200
#define argent_joueur 1000

#define y_tir 475
#define x_tir 165


/**
 * \fn void gestion_environnement(t_wave *vague_ennemie,t_wave *vague_joueur, tir *t)
 * \brief fonction qui sert à gérer l'environnement et ses interactions avec les entités ainsi que l'interaction des entités elles-mêmes. Une entité s'arrete lorsqu'elle se trouve face à un ennemi en face d'elle et l'attaque. Les autres qui suivent derrière s'arrêtent aussi. Il s'agit de paramétrer et de configurer les limites physiques de l'environnement ainsi que leur conditions
 * \param t_wave *vague_ennemie,t_wave *vague_joueur, tir *t
 * \return void
 */
void gestion_environnement_classique(t_wave *vague_ennemie, t_wave *vague_joueur, joueur *player1,joueur *player2, SDL_Renderer *rendu)
{ // fonction qui vérifie qu'un élément ne rentre pas en contact avec un autre
  vague_ennemie = deb_liste_survivant(vague_ennemie);
  vague_joueur = deb_liste_survivant(vague_joueur);
  if (vague_ennemie != NULL)
  {
    if (vague_ennemie->ent->x <= 400)
    {
      if (player1->def != NULL && player1->t == NULL)
      {
        if (!player1->def->temps)
        {
          player1->t = creer_tir(player1->t, x_tir, y_tir);
          player1->def->temps = 20;
        }
        else
          player1->def->temps--;
      }
    }
    else if (player1->def != NULL)
      player1->def->temps = 0;
  }
  else if (player1->def != NULL)
    player1->def->temps = 0;
  gestion_ligne_entite(vague_ennemie, 1);
  gestion_ligne_entite(vague_joueur, 0);
  attaque_entites(vague_ennemie, vague_joueur, player1);
  
  animation_attaque(rendu, vague_ennemie);
  animation_attaque(rendu, vague_joueur);
  animation_tir_gauche(rendu, player1);
  animation_tir_droite(rendu,player2);
  player1->t = etat_tir(player1->t); /*on met à jour le tir si besoin*/
  player1->def = etat_defense(player1->def);

  player2->t = etat_tir(player2->t); /*on met à jour le tir si besoin*/
  player2->def = etat_defense(player2->def);
}

t_wave*
charger_niveau_classique(char *nom)
{ // charge le niveau à partir d'un fichier txt
  FILE *fichier = fopen(nom, "r");
  if (fichier == NULL)
    return NULL;
  int temps = 0;
  char nom_template[100];
  char nom_template_attaque[100];
  fscanf(fichier, "%s", nom_template);
  fscanf(fichier, "%s", nom_template_attaque);

  t_wave *vagues = creer_vague();
  if (vagues == NULL)
    return NULL;

  while (!feof(fichier))
  {
    strcpy(vagues->ent->nom_fichier, nom_template);
    strcpy(vagues->ent->nom_fichier_attaque, nom_template_attaque);
    printf("adresse : %p\n", vagues);
    fscanf(fichier, "%d/%d/%d/%d/%d/%d", &vagues->ent->pv,
           &vagues->ent->montant, &vagues->ent->x, &vagues->ent->x_barre,
           &vagues->ent->y_barre, &vagues->ent->degat);
    vagues->ent->temps = temps;
    vagues->ent->y = y_entity;
    vagues->ent->attaque = 1;
    temps += 50;
    printf("%s\npv : %d\nmontant : %d\nx : %d\ntemps : %d\n\n",
           vagues->ent->nom_fichier, vagues->ent->pv, vagues->ent->montant,
           vagues->ent->x, vagues->ent->temps);
    vagues = ajouter_entite_survivant(vagues);
  }

  printf("test\n");
  vagues = supprimer_entite_survivant(vagues);
  vagues = supprimer_entite_survivant(vagues);
  printf("adresse en sortie de for : %p\n", vagues);
  printf("%s\npv : %d\nmontant : %d\nx : %d\ntemps : %d\n\n",
         vagues->ent->nom_fichier, vagues->ent->pv, vagues->ent->montant,
         vagues->ent->x, vagues->ent->temps);
  fclose(fichier);
  return vagues;
}


void met_a_jour_images_classique(t_wave *vagues)
{
  if (vagues != NULL)
  {
    if (vagues->ent->montant == 2)
      return;
    else
    {
      if (vagues->ent->nom_fichier[25] < 57 && vagues->ent->montant)
      {
        vagues->ent->nom_fichier[25]++;
        if (!fichier_existe(vagues->ent->nom_fichier))
          vagues->ent->nom_fichier[25]--;
      }
      else if (vagues->ent->nom_fichier[25] == 57 && vagues->ent->montant)
      {
        vagues->ent->nom_fichier[25]--;
        if (!fichier_existe(vagues->ent->nom_fichier))
          vagues->ent->nom_fichier[25]++;
        vagues->ent->montant = 0;
      }
      else if (vagues->ent->nom_fichier[25] > 49 && !vagues->ent->montant)
      {
        vagues->ent->nom_fichier[25]--;
        if (!fichier_existe(vagues->ent->nom_fichier))
          vagues->ent->nom_fichier[25]++;
      }
      else if (vagues->ent->nom_fichier[25] == 49 && !vagues->ent->montant)
      {
        vagues->ent->nom_fichier[25]++;
        if (!fichier_existe(vagues->ent->nom_fichier))
          vagues->ent->nom_fichier[25]--;
        vagues->ent->montant = 1;
      }
    }
  }
}


int deroulement_vagues_classique(joueur *player, t_wave *vagues, SDL_Renderer *rendu,
                       int camp)
{ /**/
  int code_contour_barre_vie[4] = {0, 0, 0, 255};
  int code_interieur_barre_vie[4] = {255, 165, 0, 255};
  vagues = deb_liste_survivant(vagues);
  if (vagues != NULL)
  {
    while (vagues->suiv != NULL)
    {
      if (!vagues->ent->temps && vagues->ent->pv > 0)
      {
        if (vagues->ent->attaque != 0)
          charger_image(vagues->ent->nom_fichier, rendu, vagues->ent->x,
                        vagues->ent->y, 0);
        met_a_jour_images_classique(vagues);

      /* int xbarre = vagues->ent->x;
      int ybarre = vagues->ent->y_barre + 10; */

        dessiner_rectangle_vide(rendu, code_contour_barre_vie,  
                                vagues->ent->x,
                                vagues->ent->y_barre + 10, 8, 52, 
                                0); /*met à jour la barre de vie*/
        dessiner_rectangle_plein(
            rendu, code_interieur_barre_vie, vagues->ent->x + 1,
            vagues->ent->y_barre + 1 + 10, 6, vagues->ent->pv, 0);
        if (camp && vagues->ent->montant != 2)
        {
          vagues->ent->x -= 2;
          vagues->ent->x_barre -= 2;
        }
        else if (!camp && vagues->ent->montant != 2)
        {
          vagues->ent->x += 2;
          vagues->ent->x_barre += 2;
        }
      }
      else if (vagues->ent->temps > 0)
      {
        vagues->ent->temps--;
        vagues = suivant_entite_survivant(vagues);
      }
      if (vagues->ent->pv <= 0)
      {
        vagues = supprimer_entite_survivant(vagues);
        if (camp)
          player->argent += 130;
        if (vagues == NULL)
          return -1;
      }
      else if (vagues->ent->pv > 0 && !vagues->ent->temps)
        vagues = suivant_entite_survivant(vagues);
    }
  }
  if (vagues != NULL)
  { // dans le cas ou il ne reste plus qu'une entité dans
    // la liste ou on est à la fin
    if (!vagues->ent->temps && vagues->ent->pv > 0)
    {
      // printf("derniere adresse : %p\n", vagues);
      if (vagues->ent->attaque != 0)
        charger_image(vagues->ent->nom_fichier, rendu, vagues->ent->x,
                      vagues->ent->y, 0);
      met_a_jour_images_classique(vagues);
      dessiner_rectangle_vide(rendu, code_contour_barre_vie,
                              vagues->ent->x_barre, vagues->ent->y + 10,
                              8, 52, 0); /*met à jour la barre de vie*/
      dessiner_rectangle_plein(
          rendu, code_interieur_barre_vie, vagues->ent->x_barre + 1,
          vagues->ent->y + 11, 6, vagues->ent->pv, 0);
      if (camp && vagues->ent->montant != 2)
      {
        vagues->ent->x -= 2;
        vagues->ent->x_barre -= 2;
      }
      else if (!camp && vagues->ent->montant != 2)
      {
        vagues->ent->x += 2;
        vagues->ent->x_barre += 2;
      }
    }
    if (vagues->ent->temps > 0)
      vagues->ent->temps--;
    if (vagues->ent->pv <= 0)
    {
      vagues = supprimer_entite_survivant(vagues);
      if (camp)
        player->argent += 130;
      if (vagues == NULL)
        return -1;
    }
  }
  else
    return 1;
  return 0;
}




int fin_partie_classique(t_wave *vagues)
{
  vagues = vider_liste_survivant(vagues);
  return (vagues == NULL);
}

t_wave *
ajouter_voisin_classique(joueur *player, t_wave *vague, message *msg)
{
  if (player != NULL)
  {
    if (player->argent >= 100)
    {
      vague = fin_liste_survivant(vague);
      if (vague == NULL)
      {
        t_wave *nouv = creer_vague();
        nouv->ent->temps = 0;
        strcpy(nouv->ent->nom_fichier,
               "data/entities/voisn/voisin1.png");
        strcpy(nouv->ent->nom_fichier_attaque,
               "data/entities/voisn/voisintir.png");
        nouv->ent->pv = 50;
        nouv->ent->montant = 1;
        nouv->ent->x = 110;
        nouv->ent->y = y_entity;
        nouv->ent->attaque = 1;
        nouv->ent->x_barre = 130;
        nouv->ent->y_barre = 450;
        nouv->ent->degat = 10;
        printf("nouv\n");
        player->argent -= 100;
        return nouv;
      }
      else
        vague = ajouter_entite_survivant(vague);
      if (vague->prec != NULL)
      {
        printf("différent de NULL !!!!\n");
        vague->ent->temps = 50 + vague->prec->ent->temps;
        printf("temps : %d\n", vague->ent->temps);
      }
      strcpy(vague->ent->nom_fichier, "data/entities/voisn/voisin1.png");
      strcpy(vague->ent->nom_fichier_attaque,
             "data/entities/voisn/voisintir.png");
      vague->ent->pv = 50;
      vague->ent->montant = 1;
      vague->ent->x = 110;
      vague->ent->y = y_entity;
      vague->ent->attaque = 1;
      vague->ent->x_barre = 130;
      vague->ent->y_barre = 450;
      vague->ent->degat = 10;
      printf("ancien\n");
      player->argent -= 100;
      return vague;
    }
    else
      message_box(msg, "data/inventaire/pasassez.png");
  }
  return vague;
}

t_wave *
ajouter_voisin_reverse(joueur *player, t_wave *vague, message *msg)
{
  if (player != NULL)
  {
    if (player->argent >= 100)
    {
      vague = fin_liste_survivant(vague);
      if (vague == NULL)
      {
        t_wave *nouv = creer_vague();
        nouv->ent->temps = 0;
        strcpy(nouv->ent->nom_fichier,
               "data/entities/voisn/voisin1.png");
        strcpy(nouv->ent->nom_fichier_attaque,
               "data/entities/voisn/voisintir.png");
        nouv->ent->pv = 50;
        nouv->ent->montant = 1;
        nouv->ent->x = 1250-110;
        nouv->ent->y = y_entity;
        nouv->ent->attaque = 1;
        nouv->ent->x_barre = 130;
        nouv->ent->y_barre = 450;
        nouv->ent->degat = 10;
        printf("nouv\n");
        player->argent -= 100;
        return nouv;
      }
      else
        vague = ajouter_entite_survivant(vague);
      if (vague->prec != NULL)
      {
        printf("différent de NULL !!!!\n");
        vague->ent->temps = 50 + vague->prec->ent->temps;
        printf("temps : %d\n", vague->ent->temps);
      }
      strcpy(vague->ent->nom_fichier, "data/entities/voisn/voisin1.png");
      strcpy(vague->ent->nom_fichier_attaque,
             "data/entities/voisn/voisintir.png");
      vague->ent->pv = 50;
      vague->ent->montant = 1;
      vague->ent->x = 110;
      vague->ent->y = y_entity;
      vague->ent->attaque = 1;
      vague->ent->x_barre = 130;
      vague->ent->y_barre = 450;
      vague->ent->degat = 10;
      printf("ancien\n");
      player->argent -= 100;
      return vague;
    }
    else
      message_box(msg, "data/inventaire/pasassez.png");
  }
  return vague;
}



int etat_partie_classique(joueur *player1, joueur *player2)
{ // retourne l'état de la partie (0 si elle est toujours
  // en cours, 2 si le joueur a gagné, -1 si il a perdu)
  if (player1 != NULL && player2 != NULL)
  {
    if (player1->pv < 0)
        return 2;
    if(player2->pv < 0)
      return -2;
    else
      return 0;
  }
  return 1; // si on est pas rentré
}



int demarrer_classique(SDL_Window *window, SDL_Renderer *rendu, SDL_Event *event,
                       char lvl)
{ // crée un ordinateur avec le nombre de vague liées au niveau.
  int indic;
  message msg;
  message_box(&msg, 0);
  char level[100] = "data/modejeu/survivant/level1.txt";
  level[28] = lvl;
  char bg[100] = "data/backgrounds/bg1classique.png";
  bg[19] = lvl;

  //t_wave *vague_ennemies = charger_niveau_classique(level);


  t_wave *vague_joueur1 = NULL;
  t_wave*vague_joueur2 = NULL;

  joueur *player2 = NULL;
  joueur *player1 = NULL;


  player2 = creer_joueur(player2);
  player1 = creer_joueur(player1);


  printf("sortie de la fonction vague_ennemies\n");
  charger_image(bg, rendu, 0, 0, 1);
  int pause = 0;

  //t_wave *vague_ennemies = charger_niveau(level);
  
  while ((etat_partie_classique(player1, player2) == 0) && (etat_partie_classique(player2, player2) == 0))
  {
    while (SDL_PollEvent(event))
    { // on réécoute les évènements mais avec un
      // pointeur sur event car en SDL on ne peut
      // pas faire plusieurs listener d'évènements.
      //  if(etat_partie_survivant(vagues, &player)==1)return 1;//on
      //  verifie à chaque tour de boucle l'état de la partie
      //  if(etat_partie_survivant(vagues, &player)==-1)return 0;

      player1->argent = 10000;


      if (event->type == SDL_QUIT)
      { // lorsque l'utilisateur appuie sur la
        // croix rouge de la fenetre
        if (quit_message() == -1)
        {
          fin_partie_survivant(vague_joueur1);
          return -1; // on retourne -1
        }
      }

      if (event->window.event == SDL_WINDOWEVENT_RESIZED)
        SDL_SetWindowSize(window, 1250, 694);
      if ((event->motion.x >= 620 & event->motion.x <= 670) && (event->motion.y >= 10 && event->motion.y <= 50))
      {
        if (event->type == SDL_MOUSEBUTTONDOWN)
        {
          if (pause)
            pause = 0;
          else
            pause = 1;
          afficher_survivant(rendu, player1, pause);
          afficher_survivant(rendu,player2,pause);
        }
      }

      if ((event->motion.x >= 220 && event->motion.x <= 280) && (event->motion.y >= 10 && event->motion.y <= 60))
      { // pour les trois conditions qui suivent : si
        // l'utilisateur passe sa souris dans la zone d'un bouton
        // (jouer, paramètres ou quitter), on change le fond du
        // bouton en chargeant la version "over" de celui-ci
        indic = 1;
        if (event->type == SDL_MOUSEBUTTONDOWN)
          vague_joueur1 = ajouter_voisin_classique(
              player1, vague_joueur1,
              &msg); /*ajouter_voisin(player, vague_joueur);*/
      }
      else if ((event->motion.x >= 290 && event->motion.x <= 350) && (event->motion.y >= 10 && event->motion.y <= 60))
      { // pour les trois conditions qui suivent : si
        // l'utilisateur passe sa souris dans la zone d'un
        // bouton (jouer, paramètres ou quitter), on
        // change le fond du bouton en chargeant la
        // version "over" de celui-ci
        indic = 2;
      }
      else if ((event->motion.x >= 360 && event->motion.x <= 420) && (event->motion.y >= 10 && event->motion.y <= 60))
      { // pour les trois conditions qui suivent : si
        // l'utilisateur passe sa souris dans la zone d'un
        // bouton (jouer, paramètres ou quitter), on
        // change le fond du bouton en chargeant la
        // version "over" de celui-ci
        indic = 3;
      }
      else if ((event->motion.x >= 430 && event->motion.x <= 500) && (event->motion.y >= 10 && event->motion.y <= 60))
      { // pour les trois conditions qui suivent : si
        // l'utilisateur passe sa souris dans la zone d'un
        // bouton (jouer, paramètres ou quitter), on
        // change le fond du bouton en chargeant la
        // version "over" de celui-ci
        indic = 4;
        if (event->type == SDL_MOUSEBUTTONDOWN)
          creer_defense(player1, x_def, y_def, 15, &msg);
      }
      else if ((event->motion.x >= 0 && event->motion.x <= 100) && (event->motion.y >= 0 && event->motion.y <= 30))
      { // pour les trois conditions qui suivent : si
        // l'utilisateur passe sa souris dans la zone d'un
        // bouton (jouer, paramètres ou quitter), on
        // change le fond du bouton en chargeant la
        // version "over" de celui-ci
        indic = 5;
        if (event->type == SDL_MOUSEBUTTONDOWN)
        {
          if (return_message() == -1)
          {
            fin_partie_classique(vague_joueur1);
            return 0;
          }
        }
      }

      else if ((event->motion.x <= 1250-220 && event->motion.x >= 1250-280) && (event->motion.y >= 10 && event->motion.y <= 60))
      { // pour les trois conditions qui suivent : si
        // l'utilisateur passe sa souris dans la zone d'un bouton
        // (jouer, paramètres ou quitter), on change le fond du
        // bouton en chargeant la version "over" de celui-ci
        indic = 6;
                printf("sa marche 6 \n");

        if (event->type == SDL_MOUSEBUTTONDOWN)
          vague_joueur2 = ajouter_voisin_reverse(
              player2, vague_joueur2,
              &msg); /*ajouter_voisin(player, vague_joueur);*/
      }

      else if ((event->motion.x >= 1250-290 && event->motion.x <= 1250-350) && (event->motion.y >= 10 && event->motion.y <= 60))
      { // pour les trois conditions qui suivent : si
        // l'utilisateur passe sa souris dans la zone d'un
        // bouton (jouer, paramètres ou quitter), on
        // change le fond du bouton en chargeant la
        // version "over" de celui-ci
        indic = 7;
        printf("sa marche 7 \n");
      }


      else
        indic = 0;
      if (msg.temps > 0)
      {
        printf("temp>0\n");
        if (fichier_existe(msg.nom_fichier))
          charger_image(msg.nom_fichier, rendu, msg.x, msg.y, 0);
        else
          printf("fichier existe pas pour msg\n");
        msg.temps--;
      }
      else
        printf("temps==0\n");
    }
  
    if (!pause)
    {
      charger_image(bg, rendu, 0, 0, 0);
      charger_image("data/inventaire/backover.png", rendu, 0, 10, 0);
      charger_image("data/inventaire/carre1.png", rendu, 220, 10, 0);
      charger_image("data/inventaire/carre.png", rendu, 290, 10, 0);
      charger_image("data/inventaire/carre.png", rendu, 360, 10, 0);
      charger_image("data/inventaire/carre4.png", rendu, 430, 10, 0);
      charger_image("data/inventaire/carreover.png", rendu, 220, 10, 0);
      charger_image("data/inventaire/carreover.png", rendu, 290, 10, 0);
      charger_image("data/inventaire/carreover.png", rendu, 360, 10, 0);
      charger_image("data/inventaire/carreover.png", rendu, 430, 10, 0);
      charger_image("data/inventaire/piece1.png", rendu, 20, 40, 0);
      charger_image("data/inventaire/retoursurv.png", rendu, 60, 10, 0);
      if (indic != 1)
        charger_image("data/inventaire/carre1.png", rendu, 220, 10, 0);
      if (indic != 2)
        charger_image("data/inventaire/carre.png", rendu, 290, 10, 0);
      if (indic != 3)
        charger_image("data/inventaire/carre.png", rendu, 360, 10, 0);
      if (indic != 4)
        charger_image("data/inventaire/carre4.png", rendu, 430, 10, 0);
      if (indic != 5)
        charger_image("data/inventaire/back.png", rendu, 0, 10, 0);
      
      //inverse
      charger_image("data/inventaire/carre1.png", rendu, 1250-220-60, 10, 0);
      charger_image("data/inventaire/carre.png", rendu, 1250-360-60, 10, 0);
      charger_image("data/inventaire/carre.png", rendu, 1250-290-60, 10, 0);
      charger_image("data/inventaire/carre4.png", rendu, 1250-430-60, 10, 0);
      charger_image("data/inventaire/carreover.png", rendu, 1250-220-60, 10, 0);
      charger_image("data/inventaire/carreover.png", rendu, 1250-290-60, 10, 0);
      charger_image("data/inventaire/carreover.png", rendu, 1250-360-60, 10, 0);
      charger_image("data/inventaire/carreover.png", rendu, 1250-430-60, 10, 0);
      charger_image("data/inventaire/piece1.png", rendu,1250-0-60, 40, 0);
      if (indic != 6)
        charger_image("data/inventaire/carre1.png", rendu, 1250-220-60, 10, 0);
      if (indic != 7)
        charger_image("data/inventaire/carre.png", rendu, 1250-290-60, 10, 0);
      if (indic != 3)
        charger_image("data/inventaire/carre.png", rendu, 1250-360-60, 10, 0);
      if (indic != 4)
        charger_image("data/inventaire/carre4.png", rendu, 1250-430-60, 10, 0);
      

    }
    //afficher_survivant(rendu, player1, pause);
    afficher_survivant(rendu, player1,pause);
    gestion_environnement_classique(vague_joueur2, vague_joueur1, player1, player2, rendu);

    //gestion_environnement(vague_ennemies, vague_joueur, player1, rendu);
    if (!pause)
    {
      /* if (deroulement_vagues(player1, vague_ennemies, rendu, 1) == -1)
        vague_ennemies = NULL; */
      if (deroulement_vagues(player1, vague_joueur1, rendu, 0) == -1)
        vague_joueur1 = NULL;
      if (deroulement_vagues_classique(player2, vague_joueur2, rendu, 1) == -1)
        vague_joueur2 = NULL;
    }
    SDL_RenderPresent(rendu);
  }


  if (etat_partie_classique(player1, player2) == 2)
  {
    free(player1);
    fin_partie_classique(vague_joueur1);
    charger_image("data/inventaire/gagne.png", rendu, 400, 300, 1);
    SDL_Delay(1500);
    return 1;
  }
  else if (etat_partie_classique(player1,player2) == -1)
  {
    free(player1);
    fin_partie_classique(vague_joueur1);
    charger_image("data/inventaire/perd.png", rendu, 400, 300, 1);
    SDL_Delay(1500);
    return 0;
  }
  return 0;
}
